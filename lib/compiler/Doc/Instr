%%
%%  This file documents the machine instructions used by the new
%%  compiler as well as the assumptions (maybe context-sensitive)
%%  that the emulator makes.  Not respecting these assumptions may
%%  corrupt the internal state of the emulator; they must therefore
%%  be enforced by a byte-code-verifier in order not to compromise
%%  security.
%%
%%  Notes:
%%  -- After each instruction its parameters are listed, one
%%     parameter per line.  The type and a comment are given for
%%     each parameter.
%%  -- For some instructions, an equivalent instruction sequence
%%     may be given after the "==" sign.
%%  -- Instructions after the "^=" sign give a kind of pseudo-code
%%     for an instruction.
%%
%%  General assumptions:
%%  -- Although the Emulator uses more instructions internally
%%     than those described in this document, none of the non-listed
%%     instructions may appear inside the user code area.
%%  -- No instruction may reference an address outside the current
%%     definition or inside a nested definition or thread (this will
%%     be easier to check with the introduction of segments).  Every
%%     instruction must be directly followed by another instruction,
%%     with no garbage bytes in-between.  Labels may only reference
%%     the address of instructions, not of the operands.
%%  -- If an instruction carries a Posint argument (number of live
%%     X registers), then no X register with a greater index may
%%     be read subsequently (unless reinitialized).
%%  -- There may not be an instruction sequence that executes
%%     infinitely without offering the possibility of thread
%%     preemption.  Since `return' is an instruction offering
%%     this possibility, we require the code not to have loops
%%     implemented by branches.
%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Definitions
%%
%%  The following instructions always have to be used in the
%%  following manner:
%%
%%  lbl(L1)   definition(_ L2 _ _ [R1 ... Rn])
%%            profileProc        % optional
%%            ...
%%            endDefinition(L1)
%%            localVarname(_)    % either 0 or as many as the environment size
%%            ...                % (if these are present, there may only be one
%%            localVarname(_)    % allocateL/deAllocateL in the procedure)
%%            globalVarname(_)   % either 0 or n
%%            ...
%%            globalVarname(_)
%%  lbl(L2)
%%
%%  Neither of endDefinition, localVarname or globalVarname may ever be
%%  executed by the emulator.  Slots of the local environments named via
%%  localVarname (by a name other than '') may only be written to once
%%  (and possibly be cleared via clearY).  In a linear run through the
%%  code, definitions must always be correctly nested like this.
%%

definition
   XRegisterIndex   register in which to store the created abstraction
   Label            address to jump to after abstraction creation
   PredId           print name, arity, source coordinates of the abstraction
   PredicateRef     address of an AbstractionEntry or 0
   GRegRef          contents of abstraction's local G registers

profileProc

endDefinition
   Label            address of the corresponding 'definition' instruction

localVarname
   Variablename     print name of the next Y register or ''

globalVarname
   Variablename     print name of the next G register or ''


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Moving Data Around
%%

move
   Register         source
   Register         destination, may not be a G register

moveMoveXYXY        == move(x(Arg1) y(Arg2)) move(x(Arg3) y(Arg4))
   XRegisterIndex
   YRegisterIndex
   XRegisterIndex
   YRegisterIndex

moveMoveYXYX        == move(y(Arg1) x(Arg2)) move(y(Arg3) x(Arg4))
   YRegisterIndex
   XRegisterIndex
   YRegisterIndex
   XRegisterIndex

moveMoveXYYX        == move(x(Arg1) y(Arg2)) move(y(Arg3) x(Arg4))
   XRegisterIndex
   YRegisterIndex
   YRegisterIndex
   XRegisterIndex

moveMoveYXXY        == move(y(Arg1) x(Arg2)) move(x(Arg3) y(Arg4))
   YRegisterIndex
   XRegisterIndex
   XRegisterIndex
   YRegisterIndex


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Creation of Variables
%%

createVariable
   Register         destination, may not be a G register

createVariableMove  == createVariable(Arg1) move(Arg1 x(Arg2))
   Register         destination, may not be a G register
   XRegisterIndex   co-destination


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Allocation of New Data Structures
%%
%%  After a putList, the values of exactly two subtrees must be initialized
%%  by the setConstant/setValue/setVariable/setVoid instructions.
%%  After a putRecord, the values of exactly a number of subtrees equal to
%%  the with of the record must be initialized by the above instructions.
%%  The subtree initialization instructions may only appear directly
%%  after putList/putRecord.
%%

putConstant
   Constant
   Register         destination, may not be a G register

putList             ^= putRecord('|' 2 Arg1)
   Register         destination, may not be a G register

putRecord
   Literal          record label, may not be '|' if Arg2 == 2
   RecordArity      record arity, may not be 2 if Arg1 == '|'
   Register         destination, may not be a G register

setConstant
   Constant         source

setValue
   Register         source

setVariable         == createVariable(Arg1) setValue(Arg1)
   Register

setVoid
   Posint           number of arguments to set to `_'


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Matching and Unifying Data Structures
%%
%%  After a getList, the values of exactly two subtrees must be unified
%%  by the unifyNumber/unifyLiteral/unifyValue/unifyVariable/unifyValVar/
%%  unifyVoid instructions.
%%  After a putRecord, the values of exactly a number of subtrees equal
%%  to the with of the record must be unified by the above instructions.
%%  The subtree unification instructions may only appear directly
%%  after getList/getRecord.
%%

getNumber
   Number
   Register

getLiteral
   Literal
   Register

getList             ^= getRecord('|' 2 Arg1)
   Register

getListValVar       == getList(x(Arg1)) unifyValue(Arg2) unifyVariable(x(Arg3))
   XRegisterIndex
   Register
   XRegisterIndex

getRecord
   Literal          record label, may not be '|' if Arg2 == 2
   RecordArity      record arity, may not be 2 if Arg1 == '|'
   Register         value to unify with

%%  Record Argument Unification

unifyNumber
   Number

unifyLiteral
   Literal

unifyValue
   Register

unifyVariable       ^= createVariable(Arg1) unifyValue(Arg1)
   Register

unifyValVar         == unifyValue(Arg1) unifyVariable(Arg2)
   Register
   Register

unifyVoid
   Posint           number of arguments to unify with `_'


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Unification
%%

unify
   Register         operand #1
   Register         operand #2


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Allocation of Local Environments
%%
%%  Notes on local environments:
%%  The register y(I) may only be referenced after an allocateL(N) has
%%  been executed in the same procedure and if I < N.  It may only be
%%  read if it has been previously initialized explicitly.
%%  A procedure needs not have an environment.  All environments
%%  must be explicitly deallocated in the same procedure; if the
%%  deAllocateL instruction specifies a size, then it must correspond
%%  to the size given in the corresponding allocateL instruction.
%%  An allocateL instruction may only be executed if for the procedure
%%  application no environment is active.
%%  Threads created using the `thread' instruction inherit a copy of
%%  the local environment, which must thus be explicitly deallocated
%%  as well.
%%

allocateL
   Posint           size of local environment to allocate, must be \= 0

allocateL1          == allocateL(1)

allocateL2          == allocateL(2)

allocateL3          == allocateL(3)

allocateL4          == allocateL(4)

allocateL5          == allocateL(5)

allocateL6          == allocateL(6)

allocateL7          == allocateL(7)

allocateL8          == allocateL(8)

allocateL9          == allocateL(9)

allocateL10         == allocateL(10)

deAllocateL

deAllocateL1

deAllocateL2

deAllocateL3

deAllocateL4

deAllocateL5

deAllocateL6

deAllocateL7

deAllocateL8

deAllocateL9

deAllocateL10


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Applications
%%

%%
%%  Applying Builtins
%%

callBuiltin
   Builtinname
   Arity            number of argument X registers; these survive the call
                    unless Builtinname == 'Delay'

inlineFun1
   Builtinname      one of a number of special functional builtins to apply
   XRegisterIndex   argument register
   XRegisterIndex   output register
   Posint           number of X registers to save on suspension

inlineFun2
   Builtinname      one of a number of special functional builtins to apply
   XRegisterIndex   argument #1 register
   XRegisterIndex   argument #2 register
   XRegisterIndex   output register
   Posint           number of X registers to save on suspension

inlineFun3
   Builtinname      one of a number of special functional builtins to apply
   XRegisterIndex   argument #1 register
   XRegisterIndex   argument #2 register
   XRegisterIndex   argument #3 register
   XRegisterIndex   output register
   Posint           number of X registers to save on suspension

inlineRel1
   Builtinname      one of a number of special relational builtins to apply
   XRegisterIndex   argument register
   Posint           number of X registers to save on suspension

inlineRel2
   Builtinname      one of a number of special relational builtins to apply
   XRegisterIndex   argument #1 register
   XRegisterIndex   argument #2 register
   Posint           number of X registers to save on suspension

inlineRel3
   Builtinname      one of a number of special relational builtins to apply
   XRegisterIndex   argument #1 register
   XRegisterIndex   argument #2 register
   XRegisterIndex   argument #3 register
   Posint           number of X registers to save on suspension

inlineEqEq
   Builtinname      must be one of '==' or '\\='
   XRegisterIndex   argument #1 register
   XRegisterIndex   argument #2 register
   XRegisterIndex   argument #3 register
   Posint           number of X registers to save on suspension

inlineDot
   XRegisterIndex   argument #1 register
   Feature          argument #2 value
   XRegisterIndex   argument #3 register
   Posint           number of X registers to save on suspension
   Cache            ignored

inlineUparrow
   XRegisterIndex   argument #1 register
   XRegisterIndex   argument #2 register
   XRegisterIndex   argument #3 register
   Posint           number of X registers to save on suspension

inlineAt
   Literal          attribute
   XRegisterIndex   destination register
   Posint           number of X registers to save on suspension
   Cache            ignored

inlineAssign
   Literal          attribute
   XRegisterIndex   source register
   Posint           number of X registers to save on suspension
   Cache            ignored

%%
%%  Applying Procedures
%%

genCall
   GenCallInfo
   Arity            must be 0

call
   Register         if this is an X register, it must have index == Arity
   Arity

tailCall            == call(Arg1 Arg2) return
   Register         if this is an X register, it must have index == Arity
   Arity

marshalledFastCall
   Constant         procedure
   Posint           2 * arity + (isTailCall? 1: 0)

genFastCall
   PredicateRef     address of an AbstractionEntry
   Posint           a flag: 1 iff tail call

fastCall
   PredicateRef     address of an AbstractionEntry
   Posint           ignored

fastTailCall        == fastCall(Arg1 Arg2) return
   PredicateRef     address of an AbstractionEntry
   Posint           ignored

%%
%%  Sending Messages
%%

sendMsg
   Literal          method label
   Register         object; if an X register, it must have index == width
   RecordArity      method arity
   Cache            ignored

tailSendMsg         == sendMsg(Arg1 Arg2 Arg3 Arg4) return
   Literal          method label
   Register         object; if an X register, it must have index == width
   RecordArity      method arity
   Cache            ignored

applMeth
   ApplMethInfo     method label and arity
   Register         object

tailApplMeth        == applMeth(Arg1 Arg2) return
   ApplMethInfo     method label and arity
   Register         object


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Control Flow
%%

branch
   Label            address to jump to

return

%%
%%  Thread Creation
%%
%%  Threads are terminated when they execute a return instruction.
%%

thread
   Label            address to jump to after thread creation

threadX
   Posint           number of X registers to inherit
   Label            address to jump to after thread creation

%%
%%  Exception Handling
%%
%%           exHandler(L1)
%%           ...          % `catch' code; exception is in x(0).
%%           ...          % May only access Y registers initialized before
%%           ...          % the exHandler instruction
%%           branch(L2)   % (typically)
%%  lbl(L1)  ...          % `try' code; may not modify any Y registers
%%           ...          % used in the handler code or execute deAllocateL
%%           popEx
%%  lbl(L2)
%%

exHandler
   Label            address to jump to after exception handler creation

popEx


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Conditionals
%%
%%           createCond(LE _)/createOr/createEnumOr
%%  lbl(L1)  nextClause(L2)
%%           clause
%%           ...          % guard code: either a thread or a flat guard
%%           ...          % (consisting only of get{Number,Literal,Record}
%%           ...          % and argument unifiers, put{Constant,Record} and
%%           ...          % argument initializers, unify and failure)
%%           ask/wait/waitTop
%%           ...
%%           branch(LC)   % (typically)
%%  lbl(Li)  nextClause(Li+1)
%%           ...          % analogously for clauses 2 to n - 1
%%  lbl(Ln)  lastClause
%%           clause
%%           ...
%%           ask/wait/waitTop
%%           ...
%%           branch(LC)
%%  lbl(LE)  ...          % `else' code
%%  lbl(LC)
%%

createCond
   Label            address of the `else' part
   Posint           number of X registers to save on suspension

createOr

createEnumOr

createChoice

clause

wait

waitTop

ask

emptyClause         == clause wait

nextClause
   Label            address of the next clause if this one fails

lastClause

%%
%%           shallowGuard(LE _)
%%           ...          % shallow guard instructions
%%           ...          % (consisting only of get{Number,Literal,Record}
%%           ...          % and argument unifiers, put{Constant,Record} and
%%           ...          % argument initializers, unify and certain builtins)
%%           shallowThen
%%           ...
%%           branch(LC)   % (typically)
%%  lbl(LE)  ...          % `else' code
%%  lbl(LC)
%%

shallowGuard
   Label            where to jump to for the `else' part
   Posint           number of X registers to save on suspension

shallowThen

%%
%%  Simple Conditionals
%%

shallowTest1
   Builtinname      one of a number of special relational builtins to apply
   XRegisterIndex   builtin argument X register
   Label            address to jump to on failure
   Posint           number of X registers to save on suspension

shallowTest2
   Builtinname      one of a number of special relational builtins to apply
   XRegisterIndex   builtin argument #1 register
   XRegisterIndex   builtin argument #2 register
   Label            address to jump to on failure
   Posint           number of X registers to save on suspension

testLiteral         % if Arg1 == Arg2 then goto Arg3 else goto Arg4
   Register
   Literal
   Label            address to jump to if equal
   Label            address to jump to if not equal
   Posint           number of X registers to save on suspension

testNumber          % if Arg1 == Arg2 then goto Arg3 else goto Arg4
   Register
   Number
   Label            address to jump to if equal
   Label            address to jump to if not equal
   Posint           number of X registers to save on suspension

testBool
   Register         value to test
   Label            address to jump to if true
   Label            address to jump to if false
   Label            address to jump to if neither true nor false
   Posint           number of X registers to save on suspension

%%
%%  Optimized Pattern-Matching Statements and Argument Fetching
%%
%%  In the beginning at each destination in the HashTableRef,
%%  up to n (width of the corresponding pattern) record arguments
%%  may be matched by the getVariable/getVarVar/getVoid instructions.
%%  These instructions may not appear at any other location in the
%%  code.
%%

switchOnTerm
   Register         value to test
   HashTableRef     destinations to choose from

getVariable
   Register

getVarVar           == getVariable(Arg1) getVariable(Arg2)
   Register
   Register

getVoid
   Posint           number of arguments for which to skip matching


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Miscellaneous
%%

skip

failure

%%
%%           lockThread(L1 _)
%%           ...      % `lock' body instructions
%%           return   % release the lock and jump to L1
%%  lbl(L1)  ...      % where to continue after releasing the lock
%%

lockThread
   Label            where to continue after the critical section
   XRegisterIndex   index of register pointing to lock
   Posint           number of X registers to save on suspension

getSelf
   XRegisterIndex   destination register

weakDet
   Register         value to watch until bound (even if to a variable)
   Posint           number of X registers to save on suspension

debugEntry
   Literal          file name
   Number           line number
   Number           column number
   Literal          comment
   Posint           number of live registers

debugExit
   Literal          file name
   Number           line number
   Number           column number
   Literal          comment
   Posint           number of live registers

clearY
   YRegisterIndex


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%%  Definition of the Argument Types
%%

Register = x(RegisterIndex)
         | y(RegisterIndex)
         | g(RegisterIndex).
XRegisterIndex = int.
YRegisterIndex = int.
GRegisterIndex = int.
Label = int.
PredId = pid(PrintName Arity FileName Line).
PredicateRef = int.
GRegRef = [Register].
Arity = int.
Literal = atom
        | name.
Number = int
       | float.
Feature = atom
        | name
        | int.
Variablename = atom.
Posint = int.
RecordArity = int   % must be > 0 and a smallInt
            | [Feature].
GenCallInfo = gci(GRegisterIndex  % register index of class/predicate
                  IsMethod        % whether it corresponds to call or applMeth
                  Name            % '' for a call, else message name
                  IsTail          % whether this is a tailCall/tailApplMeth
                  RecordArity).   % 0 for a call, else message's arity
Builtinname = builtin.
Cache = value.   % ignored
ApplMethInfo = ami(Literal RecordArity).
HashTableRef = ht(Label [HashTableEntry]).

%%
%% Auxiliary types
%%

PrintName = atom.
IsMethod = bool.
IsTail = bool.
HashTableEntry = onVar(Label)   % if this is not present, use the else-Label
               | onScalar(NumOrLit Label)
               | onRecord(Literal RecordArity Label).
NumOrLit = atom
         | name
         | int
         | float.
FileName = atom.
Line = int.
